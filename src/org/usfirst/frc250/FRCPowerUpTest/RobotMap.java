// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc250.FRCPowerUpTest;

import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.LimitSwitchNormal;
import com.ctre.phoenix.motorcontrol.LimitSwitchSource;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.CameraServer;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	public static WPI_TalonSRX driveTrainTalonSRX_Right1;
	public static WPI_TalonSRX driveTrainTalonSRX_Left1;
	public static WPI_VictorSPX driveTrainVictor_Right2;
	public static WPI_VictorSPX driveTrainVictor_Left2;
	public static DoubleSolenoid driveTrainGearShifter;
	public static WPI_TalonSRX armArmMotor1;
	public static WPI_VictorSPX armArmMotor2;
	public static SpeedController intakeIntakeLeftMotor;
	public static SpeedController intakeIntakeRightMotor;
	public static SpeedController climberClimbMotor;
	public static Compressor sharedCompressor;
	public static PowerDistributionPanel sharedPowerDistributionPanel;
	public static WPI_TalonSRX wristWristMotor;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	public static double kINTAKE_INTAKESPEED = .5;
	public static double kINTAKE_REVERSESPEEDSLOW = -1;
	public static double kINTAKE_REVERSESPEEDFAST = -.5;

	public static double kWRIST_WRISTSPEED = .1;
	public static double kWRIST_REVERSESPEED = -.1;
	public static double kWRIST_GEAR_RATIO = (14 / 64) * (30 / 60);

	public static double kWINCH_WINCHSPEED = 1;

	public static double kARM_ARMSPEED = .25;
	public static double kARM_REVERSESPEED = -.25;
	public static double kARM_ENCODER_UPR = 4096;
	public static double kARM_GEAR_AND_SPROCKET_RATIO = (22 / 60) * (20 / 60) * (15 / 32);
	public static int kARM_POSITION_ONE_VALUE = 4 * 4096;
	public static int kARM_POSITION_TWO_VALUE = 0;
	public static int kARM_POSITION_THREE_VALUE = 0;
	public static int kARM_POSITION_FOUR_VALUE = 0;
	public static int kARM_POSITION_FIVE_VALUE = 0;

	public static int kTALON_SENSOR_TIMEOUTMS = 10;

	public static double kDEADBAND_WIDTH = 0.05;
	public static double kDRIVE_SLOWTURNSPEED = 0.3;
	public static double kDRIVE_SLOWTURNTHRESHOLD = 0.5;
	public static double kDRIVE_SLOWSPEEDSPEED = 0.3;
	public static double kDRIVE_WHEEL_CIRCUMFERENCE = 19 / 12; // in feet
	public static double kDRIVE_GEARBOX_ENCODER_RATIO = 3;
	public static double kDRIVE_GEARBOX_THIRD_STAGE_RATIO = 50 / 34;
	public static double kDRIVE_GEARBOX_ENCODER_PPR = 32;

	public static void init() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		driveTrainTalonSRX_Right1 = new WPI_TalonSRX(2);

		driveTrainTalonSRX_Left1 = new WPI_TalonSRX(3);

		driveTrainVictor_Right2 = new WPI_VictorSPX(4);

		driveTrainVictor_Left2 = new WPI_VictorSPX(5);

		driveTrainGearShifter = new DoubleSolenoid(0, 0, 1);
		LiveWindow.addActuator("DriveTrain", "GearShifter", driveTrainGearShifter);

		armArmMotor1 = new WPI_TalonSRX(6);

		armArmMotor2 = new WPI_VictorSPX(7);

		intakeIntakeLeftMotor = new Spark(2);
		LiveWindow.addActuator("Intake", "IntakeLeftMotor", (Spark) intakeIntakeLeftMotor);
		intakeIntakeLeftMotor.setInverted(true);
		intakeIntakeRightMotor = new Spark(1);
		LiveWindow.addActuator("Intake", "IntakeRightMotor", (Spark) intakeIntakeRightMotor);
		intakeIntakeRightMotor.setInverted(true);
		climberClimbMotor = new Spark(0);
		LiveWindow.addActuator("Climber", "ClimbMotor", (Spark) climberClimbMotor);
		climberClimbMotor.setInverted(false);
		sharedCompressor = new Compressor(0);
		LiveWindow.addActuator("Shared", "Compressor", sharedCompressor);

		sharedPowerDistributionPanel = new PowerDistributionPanel(0);
		LiveWindow.addSensor("Shared", "PowerDistributionPanel", sharedPowerDistributionPanel);

		wristWristMotor = new WPI_TalonSRX(8);

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

		driveTrainVictor_Right2.follow(driveTrainTalonSRX_Right1);
		driveTrainVictor_Left2.follow(driveTrainTalonSRX_Left1);
		driveTrainTalonSRX_Left1.setInverted(true);
		driveTrainVictor_Left2.setInverted(true);
		armArmMotor2.follow(armArmMotor1);

		// arm talon config
		wristWristMotor.configForwardLimitSwitchSource(LimitSwitchSource.FeedbackConnector,
				LimitSwitchNormal.NormallyOpen, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		wristWristMotor.configReverseLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.Disabled,
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		wristWristMotor.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0,
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		wristWristMotor.setSensorPhase(true);
		wristWristMotor.configNominalOutputForward(0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		wristWristMotor.configNominalOutputReverse(0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		wristWristMotor.configPeakOutputForward(1, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		wristWristMotor.configPeakOutputReverse(-1, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		wristWristMotor.config_kP(0, 0.125, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		wristWristMotor.config_kI(0, 0.0009, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		wristWristMotor.config_kD(0, 0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		wristWristMotor.configMotionCruiseVelocity(Robot.prefs2.getInt("Wrist Max Velocity"),
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		wristWristMotor.configMotionAcceleration(Robot.prefs2.getInt("Wrist Max Acceleration"),
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		wristWristMotor.setSelectedSensorPosition(0, 0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		wristWristMotor.configForwardSoftLimitEnable(false, Robot.prefs2.getInt("CAN Sensor Timeout MS"));

		armArmMotor1.configForwardLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.Disabled,
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.configReverseLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.NormallyOpen,
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0,
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.setSensorPhase(false);
		armArmMotor1.configNominalOutputForward(0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.configNominalOutputReverse(0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.configPeakOutputForward(1, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.configPeakOutputReverse(-1, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.config_kP(0, 0.125, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.config_kI(0, 0.0009, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.config_kD(0, 0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.configMotionCruiseVelocity(Robot.prefs2.getInt("Arm Max Velocity"),
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.configMotionAcceleration(Robot.prefs2.getInt("Arm Max Acceleration"),
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));

		armArmMotor1.setSelectedSensorPosition(0, 0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.configForwardSoftLimitEnable(true, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.configForwardSoftLimitThreshold(Robot.prefs2.getInt("Arm Top Limit"),
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.configReverseSoftLimitEnable(true, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		armArmMotor1.configReverseSoftLimitThreshold(Robot.prefs2.getInt("Arm Bottom Limit"),
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));

		// Drive config
		driveTrainTalonSRX_Left1.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0,
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Left1.setSensorPhase(true);
		driveTrainTalonSRX_Left1.configNominalOutputForward(0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Left1.configNominalOutputReverse(0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Left1.configPeakOutputForward(1, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Left1.configPeakOutputReverse(-1, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Left1.config_kP(0, 5.0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Left1.config_kI(0, 0.000, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Left1.config_kD(0, 0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Left1.configMotionCruiseVelocity(Robot.prefs2.getInt("Drive Max Velocity"),
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Left1.configMotionAcceleration(Robot.prefs2.getInt("Drive Max Acceleration"),
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));

		driveTrainTalonSRX_Left1.setSelectedSensorPosition(0, 0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Right1.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0,
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));

		driveTrainTalonSRX_Right1.setSensorPhase(true);
		driveTrainTalonSRX_Right1.configNominalOutputForward(0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Right1.configNominalOutputReverse(0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Right1.configPeakOutputForward(1, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Right1.configPeakOutputReverse(-1, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Right1.config_kP(0, 5.0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Right1.config_kI(0, 0.000, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Right1.config_kD(0, 0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Right1.configMotionCruiseVelocity(Robot.prefs2.getInt("Drive Max Velocity"),
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));
		driveTrainTalonSRX_Right1.configMotionAcceleration(Robot.prefs2.getInt("Drive Max Acceleration"),
				Robot.prefs2.getInt("CAN Sensor Timeout MS"));

		driveTrainTalonSRX_Right1.setSelectedSensorPosition(0, 0, Robot.prefs2.getInt("CAN Sensor Timeout MS"));
	}
}
